# Building an Autocomplete Bot using Tries and Node

## Choosing data structures
Making both a node class and a trie class are necessary for the following reasons: 

Firstly, tries are a unified object in which the words emerge when a path from the root node to any valid word node is tracked. While the relationships between nodes are important in a trie, their attributes cannot single-handedly define the overall data structure of the trie. For example, if instead of starting at the root node, we start at some arbitrary node and traverse down to the leaf, we may not get a valid word as we would if we started at the root node. In order to visualize this, we can compare tries to Binary Search Trees. In a BST, any subtree of a BST must also be a valid BST for the overall tree to be considerd a valid BST. Each node in a BST satisfies the BSTs invariant, which then gives rise to the BST data strucutre. In a trie, however, subtrees will not be considered valid tries because there is no trie invariant that each node must rigidly satisfy to make the trie a valid trie. Instead, the trie is held together at the root node, and the path from the root node to any valid word node defines a valid word, and this feature of the trie makes each trie instance different from another, making it useful to create a trie class.

Secondly, each trie differs from another trie based on the word list that it is fed. Unlike BSTs, the relationships between node values are not inherent to the values since there is no condition on what letters could be the children/parents of other letters. There are also no conditions on how many children a certain node can have, or how long the height of the trie will be. All of these relationships between the nodes are defined by an externally provided list, so we definitely need a trie class that can take such a list and create the trie instance to connect every node instance with another based on these relationships. In other words, the nodes in a BST have individual values, so the relationships between such nodes can be outlined by general properties such as the BST invariant. In a trie, the values we are concerned with are a sequence of nodes, and this sequence is not determined by any trie invariant. Instead, this sequence is basically the word inserted or looke dup. As such, a trie's individual node instances need to be unified using a trie class because the branches of tries store the information we are concerned with.

Having both a trie and node class can be extremely useful, depending on how one implements it. A node class allows us to give nodes key attributes such as marking the end of valid words, or giving each node a counter attribute that increments every time the same word is entered. The trie class is useful in building the trie and defining methods to make use of these attributes. For example, we can use the node's frequency attribute to create a dicitonary of all words present in the trie, alongside their frequency. And, since we have a trie class, we can even make this dictionary an attribute of the trie itself, so we can save this informaiton and refer back to it while calling other methods. Another useful attribute could be a chronological list of all words present in the trie, created through a traversal method and saved for future use.  

## Complexity Analysis

The maximum height of a trie depends upon the length of the longest word inserted in a trie, whereas the width of the tree depends upon how many words start with a different letter in the tree. If the trie was only dealing with the English alphabet, maximum width would be 26, corresponding to the 26 English alphabet. 

When inserting a word into an empty trie, the algorithm will insert every letter of the word as a node. If the trie already has children, then it will first check if the letters of the word to be inserted are already present or not. If some of the words are, then it goes down that path, and then reaches a point where new nodes need to be inserted. In any case, the algorithm must check O(word length) time to insert a word into the tree. 

Lookup() searches if a word is present in the trie or not. If a word is present, then the algorithm will have, at most, checked as many nodes as there are letters in that word. If a word is not present, the algorithm will terminate earlier. As such, the worst_case complexity of lookup() will be O(word length). 

As compared to a BST which has a time complexity of O(logn) for operations like insert() and delete(), trie take O(L) time, where L is the length of a single word. This is much faster than BSTs in the case of a lot of latin-based languages where average word length is not very long. 

While the trie is quite efficient when compared to BST due to it's constant time look up and insert, a BST could be a lot more efficient way of storing information when the values to be stored are ordered numerically instead of alphabetically, since in that case, the BST invariant can organize and reorganize the node relationship within the BST as operations are peformed. A trie is a lot more useful when sequences of information need to be efficiently stored and quickly accessed.

## Implementation

My autocomplete() method utilizes recursion to obtain a dictionary of all the words present in the trie, with their frequencies as values. This implementation mirrors the k_most_common() method, because the recursion takes place inside a helper function - helper_recursive - which is called by both methods. This helper method finds words and appends word_freq dictionary with the values and frequencies. I implemented the code in such a way that the word_freq dictionary is an attribute of the trie. This made recursion easier and more elegant, because everytime the recursive function was called on itself, the words found along the way were stored in a dictionary outside of this function (in the trie's attribute).

Since k_most_common() also calls on helper_recursive() to fill word_freq dictionary, I had the option to just utilize the dictionary created by k_most_common() in autocomplete(). However, I decided to empty out word_freq at the beginning of autocomplete() and call the helper_recursive() function in autocomplete() as well to create a new word_freq dictionary. The intention behind this was to ensure that autocomplete() does not depend on k_most_common(), and we can run it even if we have not called k_most_common() first. 

Here, I have leveraged the benefits of object-oriented programming by creating node and tree attributes that help me implement the autocomplete() method effectively. The recursive function travels through the tree to find words, pick them up and put them in self.word_freq (an attribute of the trie), with dictionary values being the node.frequency (a node attribute). In the future, I could improve this implementation such that word_freq is created only the first time that autocomplete() is run, instead of running recursion everytime autocomplete() is called. 

After word_freq dictionary is obtained, the dictionary is sorted by word frequency in descending order such that the word with the highest frequency is the first element. Next, we simply filter this dictionary for all words that start with the given prefix, and add those values to a list called prefix_words. After this list is obtained, the last thing to do is return the word that has the highest corresponding frequency among all words that start with this prefix. If no such words are found, then the function simply returns the prefix itself. The method deals with ties between k_most_common words for a given prefix by simply returning the word with a higher alphabetical rank according to its unicode value.   

I believe this is a strong implementation of an autocomplete algorithm, where I have used the strengths of both recursion and object-oriented programming to find words in a trie (through recursion), store their frequencies using node attributes, and create a dictionary using trie attributes, so the only thing left is to sort the dictionary and filter it for words starting with a given prefix, and return the word with the highest frequency to complete a string. 
